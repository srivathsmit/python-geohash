開発メモ

## x86 80bit 浮動小数 ##
geohash C extension 内では、浮動小数のバイト列を直接操作している。この際には IEEE 754 で仕様定義されている 64bit binary を想定している。実は Intel x86 の場合はアセンブラコードを書くことで計算途中のレジスタにある 80bit を取り出すことができて、より精度を高めることができる。

_…しかし 80bit 必要だろうか？たぶん必要ないので、この先に踏み込むのはやめておく。_

## Visual Studio ##
gcc で開発していると、C99 仕様をあたりまえのように使ってしまう。ところが Visual C++ のコンパイラ cl.exe は C99 には対応していないので、変数定義などで不自由になる。Visual C++ は、その名の通り基本的に C++ なので、C++ で動作させたほうが便利になるようだ。

cl のオプションで C のソースコードを C++ のソースとして解釈してコンパイルすることができる。/Tp や /TP というオプション引数がある。ところが python distutils のセットアップの都合上、この手を使うのは、やっかいになる。

ここで発想を逆転させて、g++ を C99 のように使うことを試みる。基本的には C99 の C 言語で書きたいところだけれども、世の中の状況的にそれがままならないので、C99 流儀で書いた C++ のソースを C++ コンパイラでコンパイルするということ。幸いなことに stdint.h など C99 のヘッダには C++ で使用した際の逃げ道も用意されているので、それを使う。たとえば stdint.h であれば、`__STDC_CONSTANT_MACROS` などが役に立つ。


## Python Windows 版 ##
python をインタラクティブモードで起動する（つまり単に python を実行する）と、一行目に `Python 2.6.5 (r265:79096, Mar 19 2010, 21:48:26) [MSC v.1500 32 bit (Intel)] on win32` と出る。MSC とあるので、Microsoft Visual C++ でビルドされている。1500 の先頭の 15 から、6 を引くとバージョン番号になる。なぜ 6 なのかは不明。そして後半がマイナーバージョン番号で、10 で割る。この 1500 の場合は VC 9.0 という解釈になる。distutils の現在の仕様では、extension は本体と同じコンパイラを使うことになっているようなので、素直に従うと VC 9.0 つまり Visual Studio 2008 が必要。Visual Studio 2008 Express が一般的に入手可能なので、これを使うとよい。

Visual C++ の環境で自動的に設定されるマクロ([Predefined macros](http://msdn.microsoft.com/ja-jp/library/b0084kay.aspx) MSDN)の `_MSC_VER` の値と同じ。

本家で配布されているものについて、Python 2.5 は VC 8.0 でビルドされているようで、Visual Studio 2005 が必要。Python 3.1 は、現状 2.6 と同じ VC 9.0 を使っているようだ。